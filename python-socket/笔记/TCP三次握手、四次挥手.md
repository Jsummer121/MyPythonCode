## 一、TCP三次握手

### 1.1简介

&nbsp;&nbsp;&nbsp;&nbsp;按层次分，TCP 位于传输层，提供可靠的**字节流**服务。 

&nbsp;&nbsp;&nbsp;&nbsp;所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之， TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。确保数据能到达目标为了准确无误地将数据送达目标处，TCP协议采用了三次握手 （three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。

&nbsp;&nbsp;&nbsp;&nbsp;握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和 ACK（acknowledgement）。 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 

&nbsp;&nbsp;&nbsp;&nbsp;若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。

### 1.2 过程

#### 第一次

&nbsp;&nbsp;&nbsp;&nbsp;第一次握手：建立连接时，客户端发送syn包（seq=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

#### 第二次

&nbsp;&nbsp;&nbsp;&nbsp;第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（seq=k），即SYN+ACK包，此时服务器进入SYN_RECV状态。 

#### 第三次

&nbsp;&nbsp;&nbsp;&nbsp;第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

![img](E:\MyPythonCode\python-socket\笔记\tcp三次握手.png)

&nbsp;&nbsp;&nbsp;&nbsp;完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的概念：

（1）未连接队列

&nbsp;&nbsp;&nbsp;&nbsp;在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的SYN包（seq=j）开设一个条目，该条目表明服务器已收到SYN包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于 Syn_RECV状态，当服务器收到客户的确认包时，删除该条目，服务器进入ESTABLISHED状态。

（2）Backlog参数

&nbsp;&nbsp;&nbsp;&nbsp;三次握手协议表示内核为相应套接字排队的最大连接个数。SYN-ACK重传次数服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。

（3）半连接存活时间

&nbsp;&nbsp;&nbsp;&nbsp;是指半连接队列的条目存活的最长时间，也即服务器从收到SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为Timeout时间、SYN_RECV存活时间。

### 为什么要添加存活时间？

&nbsp;&nbsp;&nbsp;&nbsp;我们知道，TCP在连接时会发送SYN包给对方，但是如果对方没有返回一个ACK包，那此时SYN会重新发送一个SYN包进行确认（就相当于你跟妈妈打电话，和妈妈说几点回家，她却没有反应，你这时可以在重复说一下）。但是如果没有一个节制，你就会浪费资源浪费时间一直在这件事情上，比如我们没有设定等待的时间，那么我们就会一直发一直发，直到对方给我们消息为止，但是如果对方网络故障呢？我们就一直等着么。所以这里引入一个存活时间，在这个时间内，会重新发送几次，但是当等待的时间超过这个值后，我们就将这个队列删除（就相当于你和好朋友约好吃饭，8点到但是你等到8点，他还没来。此时你觉得他可能有时，你就说我在等你1h吧，当9点之前你朋友来了，你们就可以继续做之前计划的事情，但是你朋友没有那你就可以直接回家了，你可以间接的判定你朋友应该是有些事情）。

## 二、TCP四次挥手

### 2.1 简介

&nbsp;&nbsp;&nbsp;&nbsp;对于一个已经建立的连接，TCP使用改进的四次握手来释放连接（使用一个带有FIN附加标记的报文段）。

&nbsp;&nbsp;&nbsp;&nbsp;由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

### 2.2 过程

#### 第一步

&nbsp;&nbsp;&nbsp;&nbsp;当主机A的应用程序通知TCP数据已经发送完毕时，TCP向主机B发送一个带有FIN附加标记的报文段（FIN表示英文finish）。 

#### 第二步

&nbsp;&nbsp;&nbsp;&nbsp;主机B收到这个FIN报文段之后，并不立即用FIN报文段回复主机A，而是先向主机A发送一个确认序号ACK，同时通知自己相应的应用程序：对方要求关闭连接（先发送ACK的目的是为了防止在这段时间内，对方重传FIN报文段）。 

#### 第三步

&nbsp;&nbsp;&nbsp;&nbsp;主机B的应用程序告诉TCP：我要彻底的关闭连接，TCP向主机A送一个FIN报文段。

#### 第四步

&nbsp;&nbsp;&nbsp;&nbsp;主机A收到这个FIN报文段后，向主机B发送一个ACK表示连接彻底释放。

![img](E:\MyPythonCode\python-socket\笔记\三次握手、四次挥手.png)

## 三、整个流程图

![img](https://bkimg.cdn.bcebos.com/pic/9f2f070828381f30aaef6f86a9014c086e06f02f?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U5Mg==,g_7,xp_5,yp_5)