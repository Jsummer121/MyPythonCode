# 十-二进制数的最少数目

leetcode链接：[5626. 十-二进制数的最少数目](https://leetcode-cn.com/problems/partitioning-into-minimum-number-of-deci-binary-numbers/)

如果一个十进制数字不含任何前导零，且每一位上的数字不是 0 就是 1 ，那么该数字就是一个 十-二进制数 。例如，101 和 1100 都是 十-二进制数，而 112 和 3001 不是。

给你一个表示十进制整数的字符串 n ，返回和为 n 的 十-二进制数 的最少数目。

##### 示例1

```
输入：n = "32"
输出：3
解释：10 + 11 + 11 = 32
```

##### 示例2

```
输入：n = "82734"
输出：8
```

##### 示例3

```
输入：n = "27346209830709182346"
输出：9
```

## 最大的误区（贪心）

第一次看到这个题目，脑子里第一个想到的是贪心算法，即如果给的字符串长度为n，则首先应该想到最大值为“1”*n，然后再依次递减这个值，就可以获取到一个数目。能通过的第一个，但是后面不管咋样都超级大于给定的值。下面是自己写的代码：

```python
    def minPartitions(self, n: str) -> int:
        ans = 0
        N = len(n)
        n = int(n)
        a = "1"*N
        b = int(a,2)
        c = int(a)
        while n:
            while c <= n:
                n -= c
                ans += 1
            b -= 1
            c = int(bin(b)[2:])
        return ans
```

然后的然后就是带着这一题，用了1个半小时大眼瞪小眼结束了比赛。

## 正确解法

其实这个题目可以换一个思路，我们把整个字符串想象成一个个山脉，9表示有9层，1表示有1层。

然后我们接下来就是从第一层一层一层的将整个剖面图复制下来，然后减去即可。

举个栗子：给我们的值为“123456”，那么我们第一层投影出来的剖面图为“111111”，减去之后我们就剩下了“012345”，那么我们继续第二层的投影，整个投影就是“011111”，剩下的值为“001234”，一次类推最后一层剖面就是“000001”，那么我们就可以知道了，我们需要的最少个数就是整个数组中最大值然后将其返回就好。我们就可以利用python的内置函数找出整个字符串中最大的数即可：

```python
def minPartitions(self, n: str) -> int:
    return int(max(n))
```

