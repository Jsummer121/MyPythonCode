# numpy

###### 引言

- python中用list保存一组值，可以用来作为数组使用，由于列表的元素可以是任何对象，英雌列表中所保存的是对象的指针，为了保存一个简单的[1,2,3]，需要三个指正和三个整数对象，对于数值运算来说这种结果显然比较浪费你内存和CPU计算时间
- 此外python还提供了一个array模块，array对象和列表不同，他直接保存数值，呵呵C语言的一位数据比较类似，但是由于它不支持多维，也没有各种运算函数，因此也不适合做数值运算
- numpy的诞生弥补了这些不足，numpy提供了ndarray对象：是存储单一数据类型的多维数组



numpy是高性能科学计算和数据分析的基础包，支持为读书族与矩阵运算包括：

- 一个强大的n为数组对象ndarray，具有适量算数运算和复杂广播能力的快速且节省时间的多维数组。
- 用于对整组数据进行快速运算的标准数学函数
- 对于读写磁盘数据的工具以及用于操作内存映射文件的工具
- 线性代数，随机数生成以及傅里叶变换等功能



## ndarray

- N维数组对象ndarray是用于存放同类型元素的多维数组
- ndarray中的每个元素在内存中都有相容存储大小的区域
- ndarray中的每个元素是数据类型对象的对象简称dtype
- 可以对数组进行索引和切片
- 可以通过ndarray的方法和属性来访问和修改ndarray的内容

创建nadrray：创建数组最简单的办法就是使用array函数，它接受一切序列型的对象，然后产生一个含有传入数据的numpy数组，其中嵌套序列（等长列表组成的列表）将会被转化为一个多维数组

```
numpy.array(obkject, dtype = None, copy = True, order = None, subok = False, ndmin = 0)
```

object   数组或嵌套的数列

dtype    数组元素的数据类型 可选

copy      对象是否需要复制

order   创建数组的样式，c为行方向，F为列方向，A为任意方向

subok  默认返回一个与基类类型一致的数组

ndmin 指定生成数组的最小维度

```
import numpy as np
a = [1,2,3,4]
b = np.array(a)
print(b)
>>> array([1,2,3,4])
c = np.array([[1,2],[3,4]])
print(c)
>>>>[[1,2]
[3,4]]
```

除了np.array之外，还有一些函数也可以新建数组：

- zrrors和ones分别可以创建指定长度或者形状的全0或1数组
- empty可以创建一个没有任何具体值的数组

```
np.zeros(3) # 全0数组
np.ones(3) # 全1数组
np.zeros((3,3)) #全0二维数组 三行三列
np.zeros((3,1))  # 0二维数组 三行一列
np.zeros((1,3))
np.ones((3,3))
np.identity(3) #单位矩阵，三行三列
```

### ndarray之创建数组

创建随机数

- 均匀分布
  - np.random.rand(10,10) 创建指定形状（示例为10行10列）的数组（范围在0-1之间）
  - np.random.uniform(0,100) 创建指定范围内的一个数
  - np.random.randint(0,100) 创建指定范围内的整数
- 正态分布
  - np.random.normal(1.75,0.1,(2,3)) 给定均值/标准差/维度的正态分布

#### 创建随机数组

```
np.random.randint(0,50,5) # 随机数组，5个0-50之间的数字
np.random.randint(0,50,(3,5)) #3行5列 供15个随机数，都在0-50之间
np.random.rand(10) #10个结余[0,1)之间的随机数
np.random.standard_noraml(5) #从标准正太分部中随机采样5个数字
```

### ndarray的数组属性

| 用法       | 说明             |
| ---------- | ---------------- |
| b.size     | 数组元素个数     |
| b.shape    | 数组形状         |
| b.ndim     | 数组维度         |
| b.dtype    | 数组元素类型     |
| b.ltemsize | 数组元素字节大小 |

b.reshape()可以更改形状(3,2)变(2,3)或者其他

### 数组和标量之间的运算

数组很重要，因为它可以是我们不用编写循环即可对数据执行批量运算，这通常叫做矢量化，大小相同的数组之间的任何算数运算都会将运算应用到元素级，同样，数组与标量的算数运算也会将那个表两只传播到各个元素

```
arr = np.array([[1.,2.,3.],[4.,5.,6.]])
print(arr)
>>>array([[1., 2., 3.],
       [4., 5., 6.]])
print(1/array)
>>>array([[1.        , 0.5       , 0.33333333],
       [0.25      , 0.2       , 0.16666667]])
print(arr-arr)
>>>array([[0., 0., 0.],
       [0., 0., 0.]])
print(arr*arr)
>>>array([[ 1.,  4.,  9.],
       [16., 25., 36.]])
print(arr*0.5)
>>>array([[0.5, 1. , 1.5],
       [2. , 2.5, 3. ]])
```

### 基本的索引和切片

- 选取数据子集或单个元素的方式很多
- 以为数组很简单，从表面上看，他们跟python列表差不多
- 一位数组跟列表最重要的区别在于，数组切片是原始数据的视图，这意味着数据不会被复制，数组视图上任何修改都会直接反应到原始数组上
- 将一个表两只赋值给一个切片是，该值会自动传播到整个选取

```
arr = np.arange(10)
print(arr[5])
>>>5
print(arr[5:8])
>>>array([5,6,7])
print(arr[5:8]=12)
>>>array([0,1,2,3,4,12,12,12,8,9])
arr_slice = arr[5:8]
arr_slice[1] = 12345
print(arr)
>>>array([0,1,2,3,4,12,12345,12,8,9])
arr_slice[:] = 64
print(arr)
>>>array([0,1,2,3,4,64,64,64,8,9])
```

- 在二维数组中，个所有位置上的元素不再是标量，而是一维数组
- 可以对个元素进行递归访问，但这样有点麻烦
- 传入一个以逗号隔开的所有列表来选取单个元素
- 在多维数组中，如果省略了后面的索引，则返回对象会使一个维度低一点的ndarray

```
arr3d = np.array([[[1,2,3],[4,5,6]],[[7,8,9],[10,11,12]]])
print(arr3d)
>>>array([[[ 1,  2,  3],
        [ 4,  5,  6]],
       [[ 7,  8,  9],
        [10, 11, 12]]])
print(arr3d[0])
>>>array([[1, 2, 3],
       [4, 5, 6]])
print(arr3d[0][1])
>>>array([4, 5, 6])
```

### 数学和统计方法

可以通过数组上的一组数学函数对整个 数组或者某个轴向的数据进行统计计算

| 方法          | 说明                                             |
| ------------- | ------------------------------------------------ |
| sum           | 对数组中全部或轴向元素求和。零长度的数组的sum为0 |
| mean          | 算数平均数，零长度的数组的mean为NAN              |
| std,var       | 分别为标准差和方差，自由度可调（默认为n）        |
| min,max       | 最小值和最大值                                   |
| argmin,argmax | 分别为最小值和最大值的索引                       |
| cumsum        | 所有元素的累加                                   |
| cumprod       | 所有元素的累积                                   |

```
arr = np.random.randn(5,4) #5行4列的正太分部的数据
print(arr.mean()) #这个值和下面方法的值相同
print(np.mean(arr))
print(arr.sum())
```

**值得注意的是:**

mean和sum这类的函数可以接受一个axis参数（用于计算该轴向上的统计值）

```
arr.mean(axis=1)
arr.sum(0)
```

cumsum:按照所给定的周参数返回元素的梯形累积和，axis=0，按照行累加。axis=1，按照列累加

cumprod：按照所给定的周参数返回元素的梯形累积乘积，axis=0，按照行累积，axis=1按照列累积

```
arr = np.array([[0,1,2],[3,4,5],[6,7,8]])
arr.cumsum(0)
>>>array([[ 0,  1,  2],
       [ 3,  5,  7],
       [ 9, 12, 15]], dtype=int32)
arr.cumprod(1)
>>>array([[  0,   0,   0],
       [  3,  12,  60],
       [  6,  42, 336]], dtype=int32)
```













































